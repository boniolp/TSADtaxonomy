{
  "name": "Series2Graph",
  "full_name": "Graph-Based Subsequence Anomaly Detection",
  "category": "Graph-based",
  "Dim": "Univariate",
  "Sup": "Unsupervised",
  "Stream": false,
  "year": 2020,
  "authors": ["Paul Boniol", "Themis Palpanas"],
  "paper": "Series2Graph: graph-based subsequence anomaly detection for time series. Proc. VLDB Endow. 13, 12",
  "description": "Series2Graph is a graph-based anomaly detection algorithm for time series that transforms subsequences into nodes and their transition patterns into edges. The frequency of transitions among types of subsequences is encoded in a directed graph. Anomalies are identified based on irregular transition patterns.",
  "code": "https://github.com/TheDatumOrg/TSB-UAD",
  "url": "https://arxiv.org/abs/2207.12208",
  "bibtex": "@article{boniol2020series2graph, title={Series2Graph: Graph-based Subsequence Anomaly Detection for Time Series}, author={Boniol, Paul and Palpanas, Themis}, journal={Proc. VLDB Endow.}, volume={13}, number={12}, pages={1921--1934}, year={2020}}",
  "snippet_description": "We provide below an example of usage of Series2Graph for time series anomaly detection (from TSB-UAD benchmark). Please install TSB-UAD as follows:",
  "snippet_install": "pip install tsb-uad",
  "snippet": "```python\nimport os\nimport math\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nfrom TSB_UAD.utils.visualisation import plotFig\nfrom TSB_UAD.models.series2graph import Series2Graph\nfrom TSB_UAD.models.feature import Window\nfrom TSB_UAD.utils.slidingWindows import find_length\nfrom TSB_UAD.vus.metrics import get_metrics\n\n# Read data\nfilepath = 'PATH_TO_TSB_UAD/ECG/MBA_ECG805_data.out'\ndf = pd.read_csv(filepath, header=None).dropna().to_numpy()\nname = filepath.split('/')[-1]\n\ndata = df[:,0].astype(float)\nlabel = df[:,1].astype(int)\n\n# Pre-processing\nslidingWindow = find_length(data)\nquery_length = slidingWindow * 2\n\n# Run Series2Graph\nmodelName = 'Series2Graph'\nclf = Series2Graph(pattern_length=slidingWindow)\nclf.fit(data)\nclf.score(query_length=query_length, dataset=data)\nscore = clf.decision_scores_\n\n# Post-processing\nscore = np.array([score[0]]*math.ceil(query_length//2) + list(score) + [score[-1]]*(query_length//2))\nscore = MinMaxScaler(feature_range=(0,1)).fit_transform(score.reshape(-1,1)).ravel()\n\n# Plot result\nplotFig(data, label, score, slidingWindow, fileName=name, modelName=modelName)\n\n# Print accuracy\nresults = get_metrics(score, label, metric=\"all\", slidingWindow=slidingWindow)\nfor metric in results.keys():\n    print(metric, ':', results[metric])\n```",
  "figure_result": ""
}
